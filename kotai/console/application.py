#!/usr/bin/env python3
# =========================================================================== #

import argparse
import logging
from pathlib import Path
from string import ascii_letters
from kotai.constraints.genkonstrain import Konstrain, KonstrainExecType, KonstrainExecTypes
from kotai.plugin.CFGgrind import CFGgrind
from kotai.plugin.Clang import Clang
from kotai.plugin.PrintDescriptors import ClangPluginPrintDescriptors
from kotai.templates.benchmark import GenBenchTemplatePrefix
from kotai.Jotai import Jotai
from multiprocessing import Pool

from kotai.types import ExitCode, SysExitCode
from kotai.logconf import logFmt, sep

# --------------------------------------------------------------------------- #
'''
TODOs:
    - Wrap CFGgrind internal calls with kotai.types.cmdresult()

    - Find out which CFGgrind call creates "vgcore.XXXXXX" (temp) files and
      remove these files when they're no longer needed (or create them
      somewhere else)

    - Add checks to avoid re-running intermediate steps (check if files exist)

    - Find a way to prepend the orig. function with __attribute__((noinline))

    - Change CmdResult to a NamedTuple

    - Refactor _cmdresult() in constraints/genkonstrain.py

    - Change wrappers so they don't need to be instantiated inside the worker
      functions. Maybe remove individual file attributes and make their methods
      static, receiving these attrs as args?

    - Fix wrappers so the only remaining attributes with default values are not
      initialized with these

    - Modify Jotai.cpp to generate the new switch-based main from the prototype
'''
# --------------------------------------------------------------------------- #

class Application:

    def __init__(self, ) -> None:

        # Attribute type annotation
        self.clean: bool
        self.inputdir: list[str]
        self.nproc: int
        self.chunksize: int
        self.buildpath: str
        self.logfile: str
        self.ketList: list[KonstrainExecType]
        validkets = KonstrainExecTypes + ['all']

        self.args = argparse.Namespace()
        cli = argparse.ArgumentParser(
            prog='python -m kotai',
            description='Jotai options'
        )
        #cli.add_argument('-B', '--buildpath', default='./build')
        cli.add_argument('-c', '--clean', action='store_true', default=False)
        cli.add_argument('-i', '--inputdir', nargs='+', required=True)
        cli.add_argument('-j', '--nproc', type=int, default=12)
        cli.add_argument('-J', '--chunksize', type=int, default=-1)
        cli.add_argument('-K', choices=validkets, default='all')
        cli.add_argument('-L', '--logfile',   default='./output/jotai.log')
        cli.parse_args(namespace=self.args)

        # [-i]
        self.inputBenchmarks = [Path(p) for p in self.args.inputdir]

        # [-j]
        self.nproc = self.args.nproc if self.args.nproc > 1 else 1

        # [-J]
        self.chunksize = self.args.chunksize if self.args.chunksize > 1 else 1

        # [-K]
        if self.args.K not in KonstrainExecTypes:
            self.ketList = [ket for ket in KonstrainExecTypes]
        else:
            self.ketList = [self.args.K]

        # [-L] Creates logfile if it doesn't exist
        with open(self.args.logfile, 'w'): pass

        # Logging defaults
        logging.basicConfig(
            filename=self.args.logfile,
            filemode='w+',
            format=logFmt,
            level=logging.DEBUG
        )
        logging.debug(f'{self.args=}')


    def start(self, ) -> SysExitCode:
        return _start(self)  # Defined at the end of this file

# --------------------------------------------------------------------------- #


# Deletes the files generated by this program on a previous run
def _cleanFn(cFile: Path) -> ExitCode:
    cFileMetaDir = cFile.with_suffix('.d')
    genFiles = cFileMetaDir.glob('*')
    for file in genFiles:
        try: file.unlink(missing_ok=True)
        except Exception as e:
            logging.error(f'{e}: failed to delete {file=}')
            continue
    try: cFileMetaDir.rmdir()
    except Exception as e:
        logging.error(f'{e}: failed to delete {cFileMetaDir=}')
        return ExitCode.ERR
    else:
        logging.debug(f'Deleted {cFileMetaDir=}')
        return ExitCode.OK


# Called by _genDescriptor to save the fn name found in the benchmark.
# The name is important because we gather stats later with:
# cfggrind_info -f "benchBinPath::fnName" -s functions ...
def _getFnName(desc: str) -> ExitCode | str:
    tokens = [t for t in desc.split() if t]

    if 'no-params' in tokens:        return ExitCode.ERR
    if tokens.count('function') > 1: return ExitCode.ERR

    # The fn name is the token after the 'function' keyword
    # The -1 excludes the last token, to avoid IndexError when we +1
    try: fn = tokens[tokens.index('function', 0, -1) + 1]
    except Exception:                return ExitCode.ERR
    else:                            return fn


# Worker function mapped in a multiprocessing.Pool to run PrintDescriptors
def _genDescriptor(cFile: Path) -> ExitCode | str:
    cFileMetaDir   = cFile.with_suffix('.d')
    descriptorPath = cFileMetaDir / 'descriptor'

    printDescriptorsPlugin = ClangPluginPrintDescriptors(cFile)
    msg, err = printDescriptorsPlugin.runcmd()

    # If error: returns before creating the descriptor file
    if err == ExitCode.ERR:
        logging.error(f'PrintDescriptors error: {msg=}')
        return ExitCode.ERR

    fnName = _getFnName(msg)
    logging.debug(f'{fnName=}')
    if fnName == ExitCode.ERR:
        return ExitCode.ERR

    # Creates the output dir for the current cFile
    try: cFileMetaDir.mkdir(parents=True, exist_ok=True)
    except PermissionError as pe:
        logging.error(f'{pe}: could not create dir {cFileMetaDir=}')
        return ExitCode.ERR

    # Creates the descriptor
    try: descFile = open(descriptorPath, 'w')
    except PermissionError as pe:
        logging.error(f'{pe}: could not create file {descriptorPath=}')
        return ExitCode.ERR
    else:
        with descFile:
            try: print(msg, file=descFile)
            except Exception as e:
                logging.error(f'{e}: could not write to {descFile=}')
                return ExitCode.ERR

    logging.info(f'{descriptorPath=} written:\n{msg}\n{sep}')
    return fnName


# Worker function mapped in a multiprocessing.Pool to run Konstrain
def _runKonstrain(cFile:Path, ket: KonstrainExecType) -> ExitCode:
    cFileMetaDir   = cFile.with_suffix('.d')
    descriptorPath = cFileMetaDir / 'descriptor'

    konstrain = Konstrain(cFile, descriptorPath, ket)
    logging.info(f'{konstrain.__dict__=}')
    print(f'Running konstrain: {(cFile, descriptorPath, ket)=}')
    constraints, err = konstrain.runcmd()

    if err == ExitCode.ERR:
        logging.info(f'Konstrain error: "{constraints=}"')
        return ExitCode.ERR

    constraintsPath = cFileMetaDir / f'constraint_{ket}'
    try: konsFile = open(constraintsPath, 'w')
    except PermissionError as pe:
        logging.error(f'{pe}: could not create file {constraintsPath=}')
        return ExitCode.ERR
    else:
        with konsFile:
            for line in constraints:
                print(line, file=konsFile)
            logging.info(f'{constraintsPath=} written:\n{constraints}\n{sep}')
            return ExitCode.OK


### TODO: WARNING: GAMBIARRA AHEAD
def _runJotai(cFile: Path) -> ExitCode:

    cFileMetaDir    = cFile.with_suffix('.d')
    descriptorPath  = cFileMetaDir / 'descriptor'
    constraintsPath = cFileMetaDir / f'constraint_big-arr'  # big-arr only

    genBenchPath = cFileMetaDir / cFile.name  # big-arr only
    jotai = Jotai(constraintsPath, descriptorPath)

    # genBenchFile buffer, starting with headers
    # buffer <- includes, defines, typedefs and runtime info placeholder
    genBuffer = GenBenchTemplatePrefix

    # buffer += original benchmark function
    try: cFile_RO = open(cFile, 'r', encoding='utf-8')
    except Exception as e:
        logging.error(f'{cFile=}: {e}')
        return ExitCode.ERR
    else:
        with cFile_RO:
            genBuffer += cFile_RO.read() + f'\n\n\n{sep}\n\n'

    mainFn, err = jotai.runcmd()

    # If error: returns before creating the descriptor file
    if err == ExitCode.ERR:
        logging.error(f'Jotai error: {mainFn=}')
        return ExitCode.ERR
    else:
        genBuffer += mainFn

    # Creates the genBench
    try: genBenchFile = open(genBenchPath, 'w')
    except PermissionError as pe:
        logging.error(f'{pe}: could not create file {genBenchPath=}')
        return ExitCode.ERR
    else:
        with genBenchFile:
            try: print(genBuffer, file=genBenchFile)
            except Exception as e:
                logging.error(f'{e}: could not write to {genBenchFile=}')
                return ExitCode.ERR
    logging.info(f'{genBenchPath=} written:\n{mainFn}\n{sep}')
    return ExitCode.OK

# ---------------------------------- GAMBS ---------------------------------- #


### TODO: WARNING: GAMBIARRA AHEAD
def _compileGenBench(cFile: Path) -> ExitCode:
    cFileMetaDir = cFile.with_suffix('.d')
    optFlag      = 'O0'
    genBenchPath = cFileMetaDir / cFile.name
    genBinPath   = cFileMetaDir / f'{cFile.stem}_{optFlag}'

    # Compiles the genBench into a binary
    clang = Clang(ifile=genBenchPath, ofile=genBinPath)
    msg, err = clang.runcmd()

    if err == ExitCode.ERR:
        logging.error(f'Clang error: {msg=}')
        return ExitCode.ERR

    ## TODO: Go to Clang.py, add a proc.stderr.decode check to print warnings
    #logging.warning(f'{genBinPath=} stderr:\n{err}\n{sep}')
    logging.info(f'{genBinPath=} written:\n{msg}\n{sep}')
    return ExitCode.OK


# ---------------------------------- GAMBS ---------------------------------- #


### TODO: WARNING: GAMBIARRA AHEAD
def _runCFGgrind(cFile: Path, fnName: str) -> ExitCode:
    cFileMetaDir = cFile.with_suffix('.d')
    optFlag      = 'O0'
    genBenchPath = cFileMetaDir / cFile.name
    genBinPath   = cFileMetaDir / f'{cFile.stem}_{optFlag}'

    # Compiles the genBench into a binary
    cfgg = CFGgrind(cFile, fnName)
    msg, err = cfgg.runcmd()

    if err == ExitCode.ERR:
        logging.error(f'Clang error: {msg=}')
        return ExitCode.ERR

    ## TODO: Go to Clang.py, add a proc.stderr.decode check to print warnings
    #logging.warning(f'{genBinPath=} stderr:\n{err}\n{sep}')
    logging.info(f'{genBinPath=} written:\n{msg}\n{sep}')
    return ExitCode.OK


# ---------------------------------- GAMBS ---------------------------------- #


def _start(self: Application, ) -> SysExitCode:

    # For each directory passed with -i/--inputdir, do:
    for benchDir in self.inputBenchmarks:

        # Get all .c files in that directory
        cFiles = list(benchDir.glob('*.c'))

        if self.args.clean:
            with Pool(self.nproc) as pool:
                pool.map(_cleanFn, cFiles, self.chunksize)
                pool.close()
                pool.join()
            return ExitCode.OK

        konsArgs = [(cf, ty) for cf in cFiles for ty in self.ketList]

        with Pool(self.nproc) as pool:

            # benchDir/descriptor <- PrintDescriptors
            fnNames = {cf: fn for (cf, fn) in
                zip(cFiles, pool.map(_genDescriptor, cFiles, self.chunksize))
                if fn != ExitCode.ERR
            }
            if not fnNames:
                return '_genDescriptor failed for every input'

            # benchDir/constraints <- Konstrain
            res = pool.starmap(_runKonstrain, konsArgs, self.chunksize)
            if all(ret == ExitCode.ERR for ret in res):
                return '_runKonstrain failed for every input'

            # benchDir/genBench.c <- Jotai
            res = pool.map(_runJotai, cFiles, self.chunksize)
            if all(ret == ExitCode.ERR for ret in res):
                return '_runJotai failed for every input'

            # benchDir/genBench <- clang
            res = pool.map(_compileGenBench, cFiles, self.chunksize)
            if all(ret == ExitCode.ERR for ret in res):
                return '_compileGenBench failed for every input'

            res = pool.starmap(_runCFGgrind, fnNames.items(), self.chunksize)

            pool.close()
            pool.join()

    return ExitCode.OK


def main() -> SysExitCode:
    app = Application()
    return app.start()


# --------------------------------------------------------------------------- #


if __name__ == '__main__':
    import sys
    res = main()
    sys.exit(0 if res == ExitCode.OK else res)

# =========================================================================== #
